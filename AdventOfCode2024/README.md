## Advent of Code 2024 in Python

### Challenges
1. find mse difference between sorted values and then sum(value * freq2) (if only I could read)
2. filter reports of increasing/decreasing in bounds, brute force :<
3. look for regex patterns matching "mul\(\d+,\d+\)", "do\(\)", "don't\(\)" and process (did i build a giant state machine that solved both parts before just using the regex library in the refactor? maybe)
4. find patterns in word search (kinda boring scan of grid)
5. given instructions and ordering, build DAG with predecessors, validate and fix order
6. discover path through map with right turns, see where single obstacles create loop, brute force with a path follow optimization
7. find combination of operators (+,*,||) that make equations work with BFT search (take that, exponential)
8. find nodes in line with antennas (equidistant and then all) (why are antenna positions included in the antinodes?!)
9. defragment chunks of memory back into gaps/then only full gaps (kind of disgusting to have to do this ngl, brute force)
10. score of each trailhead (number of peaks reached) summed, then number of unique paths (who needs a visited set anyway)
11. track counts for each stone type which changes according to rules over the number of blinks (way overcomplicated the approach here/got distracted but it's fine now)
12. find area and perimeter/number of sides (corners) of regions in a grid
13. solve two variable system of equations (kind to have made pairs of buttons linearly independent and i guess estimate 100 for a was just for the combinatorial brute force people?)
14. track robot positions in grid, look for Christmas tree (wth is a Christmas tree shape?)
15. robot pushing single and double boxes
16. djikstra, then dfs of cost map to find nodes on shortest paths
17. alu sim and then find register A value for quine (not the fastest part b with the solver, generalized only for aoc valid inputs not any input register/program format)
18. bfs the increasingly dangerous maze
19. find out if patterns possible from subpatterns 
20. count start-end defined cheats through walls for 1 or <20 steps that lead to saving 100+ steps
21. 
22. find secret numbers from series of operations, locate series of changes leading to highest payout
23. 3-clique containing historian, then maximal clique (np-hard, why not)
24. run simulation of wires, then correct errors in the ripple carry adder (alphabetize what)
25. check if keys will fit in lock holes (not necessarily perfect match though)

